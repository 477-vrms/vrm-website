<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, available online at https://engineering.purdue.edu/ece477/Course/Policies/policies.html

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<base href="../../" />

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
            <img src="Files/img/BannerImgExample.jpg"/>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		<div id="content">
            <h2>Progress Report for Matthew Wen</h2>
            
            <br>

            <h4>Week 2:</h4>
            <b>Date:</b> Jan 20, 2021<br>
            <b>Total hours:</b> 30 <br>
            <b>Description of design efforts:</b><br>

            <p style="font-weight: bold; text-align: center;">Main Goals for the Week</p>
            <p>My main goals for the week is to setup up tools and environments for the team to use software wise. This includes an API backend that can be easily updated with no issue, and then getting some sort of connection setup between Brian’s already working unity code, and some API route I created in the backend. </p>

            <p style="font-weight: bold; text-align: center;">Server setup</p>
            <p>For the server, we concluded to use Google Cloud. The reason being is that AWS (Amazon Web Servers) relies on the members creating new accounts with Amazon, and Amazon EC2 Free Tier ended up being more expensive for the long run compared to Google Cloud VM Instance. Amazon EC2 and Google Cloud VM are basically Computer in the Cloud that can handle either hosting a website, or an API Gateway. Our idea is to setup an API Gateway with our Google Cloud VM instance so all our components (VR Headset, and Raspberry PI).</p>

            <p style="font-weight: bold; text-align: center;">DevOps Continuous Integration and Deployment with API Gateway</p>
            <p>We currently have this 
                <a href="https://github.com/477-vrms/vrms-api">https://github.com/477-vrms/vrms-api</a>
                repository. It is a similar replica to the ECESS API gateway 
                <a href="https://github.com/Purdue-ECESS/ecess-api">https://github.com/Purdue-ECESS/ecess-api</a>
                . The API from ECESS is developed by both me and James. Basically how it works, for every commit made to the main branch, GitHub builds and packages a docker image of our source code. After it packages the source code, it gains access to our Google Cloud Account using WIF (Workload Identity Pools): 
                <a href="https://cloud.google.com/blog/products/identity-security/enabling-keyless-authentication-from-github-actions">https://cloud.google.com/blog/products/identity-security/enabling-keyless-authentication-from-github-actions</a>. 
            </p>

            <img style="width: 100%;" src="Files/img/progress3/week2/google_wif.png"/>

            <p>
                Basically, in this tutorial, it uses a service account, in this case, [gh-actions-to-vm@mwenclubhouse.iam.gserviceaccount.com], to authenticate with GitHub. In the screenshot from Google Cloud from above, I say that if the GitHub repository is from 477-vrms/vrms-api, then it can access to my Google Cloud Account. 
                GitHub uses this authenticate to gain access to my VM instance, and then therefore delete the old image of our source code, and replace it with the new image create from GitHub. Here is an example.
                <a href="https://github.com/477-vrms/vrms-api/runs/4872020682?check_suite_focus=true">https://github.com/477-vrms/vrms-api/runs/4872020682?check_suite_focus=true</a>
            </p>

            <img style="width: 100%;" src="Files/img/progress3/week2/gh_actions.png"/>
            
            <p>
                From the first few tasks (Set up job, Checkout repository, Log in to the Container registry, Extract Metadata (tags, labels) for Docker and Build and Push to Docker image), GitHub is using its program to download our source code, and then run the build command to create an image of our image with our source code. For the next few tasks (Set up Cloud SDK), it obtain access to my Google Cloud Account, in this case “mwenclubhouse”, and obtains access to the Computer by telling Google to Generate an ssh key to login into the instance. The next step (Use GCP CLI), it runs commands directly on the instance.  For the last few steps (Post Setup Cloud SDK, Post Auth with GCP with WIF, etc), it delete the ssh key generated through this process to ensure nobody can access the instance if that key information is leaked, and then clean up building the docker container, and all other information. 
            </p>

            <p>
                One of the major reasons of doing this is that it is already setup with James and mine participation in ECESS, and we know how simple it is to setup, so we set it up to improve efficiency. In addition, it allows the team to keep the production code separate from development in any case anything breaks. If the server was a place for development, then if Brian was testing something with the server, it is going to cause roadblocks.  Lastly, Docker images retains the setup on how a program is being built, so we don’t have to worry there is a screw up between our development version compared to our production version.
            </p>

            <p>
                Brian and I actually struggled with this. We had Web Sockets not being able to transmit data to the server with a snippet of unity code we found online. We didn’t know what was the issue. As a result, we pulled aside and ensure that it worked locally so we can crack down on the issue; long story short, we were not sure at all what the issue was, but after doing a minor change, we were able to get it working. I was worried thinking that it will hopefully worked with <a href="https://ecess-api.matthewwen.com/vrms">https://ecess-api.matthewwen.com/vrms</a> (our api gateway), but nope, it ran perfectly fine because we ensure out development version run as close to what matches in production as possible.
            </p>


            <p style="font-weight: bold; text-align: center;">Server Setup</p>
            <p>
                On the server, as mentioned in the previous section, we are using Docker Containers. Here is our current configuration of how our Docker Container runs.
            </p>
            <div style="border: groove;">
                <code>
                    sudo docker run -d --env-file /home/mwenclubhouse/environments/vrms.env.list \ <br>
                        <span style="margin-left: 50px;"></span>-v /home/mwenclubhouse/vrms:/usr/src/bucket \ <br>
                        <span style="margin-left: 50px;"></span>--name vrms-api \ <br>
                        <span style="margin-left: 50px;"></span>--restart always \ <br>
                        <span style="margin-left: 50px;"></span>-p 2000:8000 \ <br>
                        <span style="margin-left: 50px;"></span>-p 2001:8001 \ <br>
                        <span style="margin-left: 50px;"></span>ghcr.io/477-vrms/vrms-api:main"
                </code>
            </div>

            <p>
                We ensure that the container we have running will run on restart, mostly because if Google decides to restart our computer, the program will automatically start up when the computer boots up. We also link port 8000 of the container to port 2000 on the Google VM, and same applies to port 8001 and 2001. Port 8001 is not used for anything at the moment besides 
            </p>
            <p>
                To deal with routing, we are using nginx; we don’t need a load balance, but it is really nice to have nginx deal with routing with our program.
            </p>
            <div style="border: groove;">
                <code style="margin: 5px;">
                    location /vrms/ { <br>
                        <span style="margin-left: 50px;"></span>proxy_pass http://127.0.0.1:2000/; <br>
                        <span style="margin-left: 50px;"></span>proxy_http_version 1.1; <br>
                        <span style="margin-left: 50px;"></span>proxy_set_header Upgrade $http_upgrade; <br>
                        <span style="margin-left: 50px;"></span>proxy_set_header Connection "Upgrade";  <br>
                        <span style="margin-left: 50px;"></span>proxy_set_header Host $host; <br>
                    } <br>
                </code>
            </div>

            <p>
                In this case, we have our docker container running on port 2000 map to 
                <a href="https://ecess-api.matthewwen.com/vrms">https://ecess-api.matthewwen.com/vrms</a>
                . As a result, 
                <a href="https://ecess-api.matthewwen.com/vrms/route">https://ecess-api.matthewwen.com/vrms/route</a>
                 links to 
                <a href="http://127.0.0.1:2000/route">http://127.0.0.1:2000/route</a> locally on the Google VM. You can see the API is online by going into 
                <a href="https://ecess-api.matthewwen.com/vrms/">https://ecess-api.matthewwen.com/vrms/</a>. 
            </p>
            <img style="width: 100%;" src="Files/img/progress3/week2/gateway_demo.png"/>

            <p style="font-weight: bold; text-align: center;">Programming Language Used for API Application</p>
            <p>
                So for the backend, we are currently using express-ws, which is a combination of both express as a REST API, and Web-Sockets.  
                <a href="https://github.com/HenningM/express-ws">https://github.com/HenningM/express-ws</a>
                . Our programming language of choice is Typescript because it performs type checking on top of javascript, so typescript can catch errors before I run into errors. On top of javascript, we are using node to run out javascript code; node is a JIT compiler that converts javascript code into machine code, which then therefore can run on our server.
            </p>

            <p style="font-weight: bold; text-align: center;">
                Benchmarking Unit Web Socket
            </p>

            <p>
                As a software engineering lead, I’m mostly in control on ensuring that all our components can communicate with each other. To reiterate the components is the Unity Software, which runs on the Virtual Reality Headset, the Server, and the IoT device. Using Brian’s Unity code, Brian had an idea to be able to upload joint data from unity to the server. In addition, we also wanted to test how fast it sends data from the server. As a result, I decided to use a Google Firebase Account, where we can use a real time Firebase database so we can easily see the data point changing. The reason on why we decided to Google Firebase because Google created an intuitive software where we can visibly see the changes. In addition, the reason of why we use Google Real Time Database then Google Firestone is because Google Real Time bills us based off the number of bytes sent, not based off of the number of requests, which is another database option offered in Firebase. Keep in mind, we are only using Firebase to check that data is being received, not as an actual service.
            </p>
            <img style="width: 100%;" src="Files/img/progress3/week2/firebase.png"/>
            <p>
            The structure is not final, as a result, if Brian needs to adjust the data to label them as more specific joints, he can adjust the data that is being posted to the Web Socket. 
            For the Web Socket, the data being sent to the server is in json format. So for this example, it is being sent like this
            </p>

            <div style="display: flex; flex-wrap: wrap; margin-top: 20px; margin-bottom: 20px;">
                <div style="border: groove;">
                    <code>
                        { <br>
                            <span style="margin-left: 50px;"></span>"Joint 1": -13.28888, <br>
                            <span style="margin-left: 50px;"></span>"Joint 2": 5.666, <br>
                            <span style="margin-left: 50px;"></span>"Joint 3": 9.42342 <br>
                        }
                    </code>
                </div>
                <div style="flex: 1; margin: 5px">
                    <p>
                        At this point of the project, we were not really concern about the data being useful, mostly that the there is a connection between the VR Unity Application and the Server. The server confirms that it obtained data from the VR headset by processing sent via JSON format and then putting it into points→person inside the database. We quickly learn that it updates really fast, even considering the fact on how fast Google Firebase Application runs via Google Servers and on the Computer we are observing the data on. However, we do notice we might be sending data a little too fast, therefore for the later weeks, we need to consider the frequency on how much data to send because sending too much data is just bad and could potentially overload the server and the robot arm badly.
                    </p>
                </div>

            </div>


            <p style="font-weight: bold; text-align: center;">What I learned</p>
            <p>
                Throughout this entire process, I learned about how service accounts work on Google Cloud, and how to connect a Google Cloud Account to a GitHub repository. In addition, I learned how to deploy an API gateway with a Docker Container with the help of using the template from ECE 468 
                <a href="https://github.com/ECE468/env-container-2021-fall">https://github.com/ECE468/env-container-2021-fall</a>
                , but we did it with node instead of antlr for them. Lastly, I learned how to deploy a web-socket application with my Google Computer (Google VM). In addition, I connected the web-socket application to both the VR headset and a database just to showcase. 
            </p>

            <p style="font-weight: bold; text-align: center;">Next Steps</p>
            <p>The original idea is to use Web Sockets for video streaming since there isn’t really a limit on how much data can be sent in a Web Socket. We also want to implement MQTT, which is also a tcp protocol that should send data faster in smaller packets since the MQTT format has a limit on the amount of data can be sent per packet. We are going to use MQTT for sending data from the unity headset to the robot.</p>

            <!-- <h4>Week 2:</h4>
            <b>Date:</b> -Enter today's date here-<br>
            <b>Total hours:</b> -Enter the number of hours you worked this week here-<br>
            <b>Description of design efforts:</b><br>
            -Discuss your design efforts here. Remember to follow the guidelines presented in the Progress Report Policy, available <a href="https://engineering.purdue.edu/ece477/Course/Policies/">here</a>. This is a template entry; simply copy/paste this entry when doing progress reports each week.</br> -->

            <br>
        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
